// Copyright (C) 2020  Gokhan Solak, CRISP, Queen Mary University of London
// This code is licensed under the BSD 3-Clause license (see LICENSE for details)

#include "spring_framework/spring_server.h"

using namespace std;
using namespace spring_framework;

/*********************************************************************
* SpringServer object runs a ros node to control a spring system.
* It handles the communication to read the state and publish
* cartesian forces generated by springs.
* It also publishes spring displays for RViz.
* This class is independent from robot hand hardware.
* contact_count is typically the number of fingers.
*   It doesn't include the virtual object frame.
* Optionally it can publish spring info (publish_springs) as a SpringNetworkMsg
* and virtual object frame (publish_transform) as a TF.
*********************************************************************/
SpringServer::SpringServer(int contact_count, shared_ptr<SpringNetwork> network,
    bool publish_springs, bool publish_transform, double control_frequency)
      : contact_count_(contact_count), publish_springs_(publish_springs),
        publish_transform_(publish_transform), control_freq_(control_frequency){

  p_logger_ = nullptr;

  // init spring resources
  network_ = network;
  control_ = make_shared<SpringController>(contact_count_, network_);
  display_ = make_shared<SpringDisplay>("spring_display");

  // initially no object control
  control_object_ = false;

  // init handles to null
  handle_update_enter_ = nullptr;
  handle_update_exit_ = nullptr;

  active_ = false;
  ready_ = false;
}
SpringServer::~SpringServer(){
}

/*********************************************************************
* Publish the force as a WrenchStamped message
*********************************************************************/
void SpringServer::publishCartForces_(const vector<geometry_msgs::Wrench> &wrench_vec){
  // Create a WrenchArray message as it fits the purpose
  kdl_control_tools::WrenchArray msg;

  msg.header.stamp = ros::Time::now();

  msg.wrenches = wrench_vec;

  // force_pub_.publish(msg);
}

/*********************************************************************
* Publish the force as a WrenchStamped message to display in RViz
*********************************************************************/
void SpringServer::visualizeFingerForce_(const int finger_no, const geometry_msgs::Vector3& force_vec, const KDL::Frame& ff_frame){

  // convert to kdl
  KDL::Vector f_kdl;

  tf::vectorMsgToKDL(force_vec, f_kdl);

  // change frame to fingertip
  f_kdl = ff_frame.M.Inverse() * f_kdl;

  // create the message
  geometry_msgs::WrenchStamped msg;

  msg.header.stamp = ros::Time::now();
  //FIXME: frame name as a param
  msg.header.frame_id = "link_" + to_string(finger_no*4+3) +"_tip";

  // assign force from kdl
  tf::vectorKDLToMsg(f_kdl, msg.wrench.force);

  msg.wrench.torque.x = 0;
  msg.wrench.torque.y = 0;
  msg.wrench.torque.z = 0;

  wrench_pub_vec_[finger_no].publish(msg);
}

/*********************************************************************
* Publish a transform to /tf for the given frame with name and parent.
* parent_tf_name must be an existing tf name in /tf.
*********************************************************************/
void SpringServer::publishObjectTransform_(const KDL::Frame& vf, const string& tf_name, const string& parent_tf_name){

  geometry_msgs::TransformStamped tf_msg;

  tf_msg.header.frame_id = parent_tf_name;
  tf_msg.header.stamp = ros::Time::now();

  tf_msg.child_frame_id = tf_name;

  tf::transformKDLToMsg(vf, tf_msg.transform);

  tf_pub_.sendTransform(tf_msg);

}

/*********************************************************************
* Callback for frame pose listener. It updates the frames.
*********************************************************************/
void SpringServer::framePoseCallback_(const geometry_msgs::PoseArray::ConstPtr &msg){
  // convert poses to kdl
  int frame_count = msg->poses.size();
  vector<KDL::Frame> frame_vec(frame_count);
  for(int fi=0; fi < frame_count; fi++){
    tf::poseMsgToKDL(msg->poses[fi], frame_vec[fi]);
  }
  // updates network frames and calculates the virtual frame
  control_->updateState(frame_vec);

  ready_ = true;
}


void SpringServer::timerCallback_(const ros::TimerEvent&){
  // wait until the frames are received
  if(!ready_) return;
  // publish the current spring network
  if(publish_springs_)
    spring_pub_.publish(network_->toMsg());

  // publish the current object virtual TF
  if(publish_transform_)
    publishObjectTransform_(control_->getVirtualFrame(), "virtual_object", "hand_root");

  // update and publish forces whenever state is updated
  updateForces_(control_->getFrames());
}
/*********************************************************************
* Procedure that updates and publishes the forces
*********************************************************************/
void SpringServer::updateForces_(const vector<KDL::Frame>& frame_vec){
  // avoid working after finishing
  if(!active_) return;

  // if enter handler exists, call it
  if(handle_update_enter_ != nullptr)
    (*handle_update_enter_)(this, frame_vec);

  // update display
  display_->updateSprings(*network_);
  display_->publishMarkers();

  // variables for force components
  vector<KDL::Vector> f_spring_vec; // spring control forces
  KDL::Vector f_pos; // position control force
  vector<KDL::Vector> f_rot_vec(contact_count_); // rotation control forces

  // calculate the total spring force for each frame
  // (a finger may be connected by multiple springs)
  control_->calcFrameForces(f_spring_vec, true);

  // control object only if stated
  if(control_object_){
    // calculate the position control force to achieve desired pose
    // (this is the same for all fingers)
    control_->calcPositionForce(pose_des_.p, vel_des_, f_pos);

    // calculate the rotation control force for each frame
    control_->calcRotationForce(pose_des_.M, f_rot_vec);
  }

  // create a wrench vec for each frame
  vector<geometry_msgs::Wrench> w_grasp_vec(contact_count_);
  vector<geometry_msgs::Wrench> w_manip_vec(contact_count_);
  for(int fi=0; fi < contact_count_; fi++){
    // convert to std vector to publish
    tf::vectorKDLToMsg(f_pos + f_rot_vec[fi], w_manip_vec[fi].force);
      // fi+1 because 0th is the object frame
    tf::vectorKDLToMsg(f_spring_vec[fi+1], w_grasp_vec[fi].force);

    // publish the force as a wrench message (only for grasp)
    visualizeFingerForce_(fi, w_grasp_vec[fi].force, frame_vec[fi]);

    // torque vector is zero
  }

  // Create a WrenchArray message and publish
  kdl_control_tools::WrenchArray msg;
  msg.header.stamp = ros::Time::now();
    // grasp
  msg.wrenches = w_grasp_vec;
  grasp_force_pub_.publish(msg);
    // manipulation
  msg.wrenches = w_manip_vec;
  manipulation_force_pub_.publish(msg);

  // if exit handler exists, call it
  if(handle_update_exit_ != nullptr)
    (*handle_update_exit_)(this, frame_vec);

}

/*********************************************************************
* Activates the control.
*********************************************************************/
void SpringServer::start(shared_ptr<ros::NodeHandle> nh_parent){
  // do nothing if running already
  if (active_) return;

  // keep the parent's NodeHandle for future (termination)
  nh_parent_ = nh_parent;

  // initiate communication
    // create force publisher for control
  grasp_force_pub_ = nh_parent_->advertise<kdl_control_tools::WrenchArray>("grasp_forces", 1);
  manipulation_force_pub_ = nh_parent_->advertise<kdl_control_tools::WrenchArray>("manipulation_forces", 1);

    // create springs publisher (optional)
  if(publish_springs_)
    spring_pub_ = nh_parent_->advertise<SpringNetworkMsg>("spring_network", 1);

    // create wrench publisher to visualize in rviz
  for (int fi=0; fi<contact_count_; fi++){
    wrench_pub_vec_.push_back(
      nh_parent_->advertise<geometry_msgs::WrenchStamped>("finger_wrench_"+to_string(fi), 1));
  }

    // create listeners
  pose_sub_ =
    nh_parent_->subscribe<geometry_msgs::PoseArray>("pose_array", 1, &SpringServer::framePoseCallback_, this, ros::TransportHints().tcpNoDelay().reliable());

  control_timer_ =
    nh_parent_->createTimer(ros::Duration(1/control_freq_), &SpringServer::timerCallback_, this);

  // start spring display
  display_->start(*nh_parent_);

  ROS_INFO("Spring server is started");

  active_ = true;
}
/*********************************************************************
* Deactivates the control. Kills (joins) the thread.
* Publishes zero forces to stop control.
*********************************************************************/
void SpringServer::stop(){
  // do nothing if not running already
  if (!active_) return;

  ROS_INFO("Spring server is stopping.");

  // send empty wrench messages
  KDL::Frame frame_empty;
  geometry_msgs::Vector3 force_empty;
  for(int fi=0; fi < contact_count_; fi++){
    visualizeFingerForce_(fi, force_empty, frame_empty);
  }

  // clean spring display
  display_->cleanMarkers();

  active_ = false;
  ready_ = false;

  // deactivate object control
  setObjectControl(false);

  // publish zero forces for grasp
  kdl_control_tools::WrenchArray msg;
  msg.header.stamp = ros::Time::now();
  msg.wrenches.resize(contact_count_);
  grasp_force_pub_.publish(msg);
  manipulation_force_pub_.publish(msg);

  // Sleep to handle communication
  ros::Duration sleep_time(0.01);
  sleep_time.sleep();

  // stop subscibers and publishers
  grasp_force_pub_.shutdown();
  manipulation_force_pub_.shutdown();
  pose_sub_.shutdown();
  for (int fi=0; fi<contact_count_; fi++){
    wrench_pub_vec_[fi].shutdown();
  }
  wrench_pub_vec_.clear();

  if(spring_pub_)
    spring_pub_.shutdown();
  // Sleep to handle communication
  sleep_time.sleep();
}
/*********************************************************************
* As an alternative to PoseArray messages, the frames can also be
* updated using this method.
* This will trigger the calculation of forces if the node is active.
*********************************************************************/
void SpringServer::setFrames(const vector<KDL::Frame>& frame_vec) {

  // updates network frames and calculates the virtual frame
  control_->updateState(frame_vec);

  // calculates the forces and publishes
  updateForces_(frame_vec);
}
/*********************************************************************
* Handlers to allow user to do something during the loop.
* This one is called at the beginning of force update loop, after
* reading the new state (frames), before calculating the forces.
*********************************************************************/
void SpringServer::setUpdateEnterHandler(function<void(const SpringServer*, const vector<KDL::Frame>&)> &fp){
  handle_update_enter_ = &fp;
}
/*********************************************************************
* Handlers to allow user to do something during the loop.
* This one is called at the end of force update loop, after
* calculating the forces and publishing the forces.
*********************************************************************/
void SpringServer::setUpdateExitHandler(function<void(const SpringServer*, const vector<KDL::Frame>&)> &fp){
  handle_update_exit_ = &fp;
}
/*********************************************************************
* starts/stops spring publishing
*********************************************************************/
void SpringServer::togglePublishSprings(const bool activate){
  // update only if the new value is different
  if(activate == publish_springs_) return;

  publish_springs_ = activate;

  // following updates are only necessary if already running
  if(!active_) return;

  if(publish_springs_)
    spring_pub_ = nh_parent_->advertise<SpringNetworkMsg>("spring_network", 1);
  else
    spring_pub_.shutdown();

}
/*********************************************************************
* starts/stops transform broadcasting for the object virtual frame
*********************************************************************/
void SpringServer::togglePublishTransform(const bool activate){

  publish_transform_ = activate;
}
/*********************************************************************
* set & get controller targets
* setting a desired pose also activates object-level impedance control
*********************************************************************/
void SpringServer::setDesiredPose(KDL::Frame p_des){
  pose_des_ = p_des;
  // activate object control
  control_object_ = true;
}
void SpringServer::setDesiredVelocity(KDL::Vector v_des){
  vel_des_ = v_des;
}

const KDL::Frame SpringServer::getDesiredPose() const{
  return pose_des_;
}
const KDL::Vector SpringServer::getDesiredVelocity() const{
  return vel_des_;
}

/*********************************************************************
* activate/deactivate object control
*********************************************************************/
void SpringServer::setObjectControl(bool state){
  control_object_ = state;
  // publish zero commanding forces if deactivating
  if(!control_object_){
    kdl_control_tools::WrenchArray msg;
    msg.header.stamp = ros::Time::now();
      // grasp
    msg.wrenches.resize(contact_count_);
    manipulation_force_pub_.publish(msg);
  }
}
bool SpringServer::getObjectControl(){
  return control_object_;
}
/*********************************************************************
* Getters and setters
*********************************************************************/
  // getters
const shared_ptr<SpringNetwork> SpringServer::getNetwork() const {
  return network_;
}
const shared_ptr<SpringController> SpringServer::getController() const{
  return control_;
}
double SpringServer::getPositionGain() const{
  return k_pos_;
}
double SpringServer::getVelocityGain() const{
  return k_vel_;
}
double SpringServer::getRotationGain() const{
  return k_rot_;
}
  // setters
void SpringServer::setPositionGain(const double k){
  k_pos_ = k;
  control_->setPositionGain(k);
}
void SpringServer::setVelocityGain(const double k){
  k_vel_ = k;
  control_->setVelocityGain(k);
}
void SpringServer::setRotationGain(const double k){
  k_rot_ = k;
  control_->setRotationGain(k);
}
/*********************************************************************
* SpringServer::connectLogger
*********************************************************************/
void SpringServer::connectLogger(shared_ptr<kdl_control_tools::ProgressLogger> logger){
  p_logger_ = logger;
  control_->connectLogger(logger);
}
